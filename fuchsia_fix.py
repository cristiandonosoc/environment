# vim: set expandtab:ts=2:sw=2
# Copyright (c) 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This file processes the compilation database generated by `fx compdb` to add
# the stl include header path. #
#
# For those who are not using clangd, you might hit the problem that you cannot
# find standard library headers such as <map> or <vector>. If so, this might
# fix your problem.
#
# Apparently this shouldn't be done as clang  should add this path by default.
# This is hooked up to YCM when using clangd.
#
# Instructions:
#
# Run this script using the generated compdb file as input. This will generate
# a "processed_db.json" file (or other path if you provided it).
# Then you should replace your compdb with the processed one.
#
# Example:
#
# cd $FUCHSIA_DIR
# fx compdb
# python scripts/youcompleteme/process_compiledb.py compile_commands.json
# mv processed_db.json compile_commands.json

import argparse
import json
import os
import sys

def ParseArgs():
  parser = argparse.ArgumentParser(description="Process compdb json file.")
  parser.add_argument("COMPDB_PATH",
          help="The generated compdb json file. See file for more info.")
  parser.add_argument("-o", "--output",
      help="The processed output json file. Default: processed_db.json",
      default="processed_db.json")
  return parser.parse_args()

def ProcessCompdb(compdb_path, output_path):
  # Load the database.
  loaded = False
  with open(os.path.expanduser(compdb_path)) as f:
    compdb_json = json.load(f)
    loaded = True

  if not loaded:
    print("Could not load compile database :(")
    sys.exit(1)

  # Process each entry within the database.
  processed_db = []
  for entry in compdb_json:
    # For now we append the include to every file.
    # May be relevant to scope this to only the files that need it, but there
    # isn't much downside to adding one more path to each entry.
    processed_db.append(ProcessEntry(entry))

  # Output the result.
  with open(os.path.expanduser(output_path), "w") as f:
    json.dump(processed_db, f, indent=2)

  print("Wrote {0} processed entries {1}.".format(len(processed_db),
                                                  output_path))

# We insert the relative path to the standard library include file to the
# compilation line of this entry.
def ProcessEntry(entry):
  cmd = entry["command"].split()

  home = os.path.expanduser("~")
  fix_path = os.path.abspath(os.path.join(home, "Source", "FuchsiaFix"))

  # Insert somewhere our include
  commands = [
    "-I", fix_path,
    "-I", "../../prebuilt/third_party/clang/linux-x64/lib/clang/10.0.0/include",
    "-I", "../../prebuilt/third_party/clang/linux-x64/include/c++/v1",
    "-Wno-format",
  ]

  append = False
  command = entry["command"]
  if "zxdb" in command:
    append = True
  elif "ipc" in command:
    if "protocol" in command:
      append = True
    if "message_writeR" in command:
      append = True
    if "records" in command:
      append = True
  elif "fidlcat" in command:
    append = True
  elif "shared" in command:
    if "logging" in command:
     append = True
  elif "message_loop" in command:
    if "message_loop_target" not in command:
      append = True
  elif "line_input" in command:
    append = True

  if append:
    commands.append("-I/usr/include")
  else:
    commands.append("-I../../prebuilt/third_party/sysroot/linux/usr/include")
    commands.append("-I../../prebuilt/third_party/sysroot/linux/usr/include/x86_64-linux-gnu")
    commands.append("-D__MY_CRAZY_LOCAL_BUILD")

  index = 10
  for c in commands:
      cmd.insert(index, c)
      index = index + 1

  entry2 = entry
  entry2["command"] = " ".join(cmd)
  return entry2

if __name__ == "__main__":
  args = ParseArgs()
  ProcessCompdb(args.COMPDB_PATH, args.output)
